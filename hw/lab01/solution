1. Перевод десятичных чисел в 6-битные двоичные
Без знака:
    1. 0 → 000000
        ◦ 0 в любой системе счисления равно 0
        ◦ Заполняем 6 нулями
    2. 13 → 001101
        ◦ 13₁₀ = 8 + 4 + 1 = 2³ + 2² + 2⁰
        ◦ Позиции: 5-4-3-2-1-0
        ◦ 13/2=6(1), 6/2=3(0), 3/2=1(1), 1/2=0(1) → 1101
        ◦ Дополняем до 6 бит: 001101
    3. 24 → 011000
        ◦ 24₁₀ = 16 + 8 = 2⁴ + 2³
        ◦ 24/2=12(0), 12/2=6(0), 6/2=3(0), 3/2=1(1), 1/2=0(1) → 11000
        ◦ Дополняем до 6 бит: 011000
    4. 63 → 111111
        ◦ 63₁₀ = 32 + 16 + 8 + 4 + 2 + 1 = 2⁵ + 2⁴ + 2³ + 2² + 2¹ + 2⁰
        ◦ 63/2=31(1), 31/2=15(1), 15/2=7(1), 7/2=3(1), 3/2=1(1), 1/2=0(1) → 111111
Со знаком (дополнительный код):
    1. 16 → 010000
        ◦ Положительное число представляется как есть
        ◦ 16₁₀ = 16 = 2⁴ → 10000
        ◦ Дополняем до 6 бит: 010000
    2. -2 → 111110
        ◦ Шаг 1: 2₁₀ = 000010
        ◦ Шаг 2: инвертируем: 111101
        ◦ Шаг 3: прибавляем 1: 111101 + 1 = 111110
    3. 31 → 011111
        ◦ Положительное число представляется как есть
        ◦ 31₁₀ = 16 + 8 + 4 + 2 + 1 → 11111
        ◦ Дополняем до 6 бит: 011111
    4. -32 → 100000
        ◦ -32 это минимальное отрицательное 6-битное число
        ◦ В дополнительном коде: 2⁵ = 32 → 100000
        ◦ Проверка: инвертируем 100000 → 011111, +1 = 100000
2. Перевод 6-битных двоичных чисел в десятичные
Беззнаковая интерпретация:
    1. 000101 = 5
        ◦ 0×2⁵ + 0×2⁴ + 0×2³ + 1×2² + 0×2¹ + 1×2⁰ = 4 + 1 = 5
    2. 101011 = 43
        ◦ 1×2⁵ + 0×2⁴ + 1×2³ + 0×2² + 1×2¹ + 1×2⁰ = 32 + 8 + 2 + 1 = 43
    3. 111111 = 63
        ◦ 1×2⁵ + 1×2⁴ + 1×2³ + 1×2² + 1×2¹ + 1×2⁰ = 32 + 16 + 8 + 4 + 2 + 1 = 63
    4. 100000 = 32
        ◦ 1×2⁵ + 0×2⁴ + 0×2³ + 0×2² + 0×2¹ + 0×2⁰ = 32
Знаковая интерпретация (дополнительный код):
    1. 000101 = +5
        ◦ Старший бит 0 → положительное число → 5
    2. 101011 = -21
        ◦ Старший бит 1 → отрицательное число
        ◦ Инвертируем: 010100
        ◦ Прибавляем 1: 010101 = 21
        ◦ Результат: -21
    3. 111111 = -1
        ◦ Старший бит 1 → отрицательное число
        ◦ Инвертируем: 000000
        ◦ Прибавляем 1: 000001 = 1
        ◦ Результат: -1
    4. 100000 = -32
        ◦ Старший бит 1 → отрицательное число
        ◦ Это специальный случай минимального числа
        ◦ В 6-битном представлении: -32
3. Перевод десятичных чисел в 8-битные шестнадцатеричные
    1. 7 → 0x07
        ◦ 7₁₀ = 7₁₆
        ◦ 8-битное представление: 00000111₂ → 07₁₆
    2. 240 → 0xF0
        ◦ 240₁₀ = 240/16=15(0), 15= F₁₆
        ◦ Результат: F0₁₆
        ◦ В двоичном: 11110000₂
    3. 171 → 0xAB
        ◦ 171₁₀ = 171/16=10(11), 10= A₁₆, 11= B₁₆
        ◦ Результат: AB₁₆
        ◦ В двоичном: 10101011₂
    4. 126 → 0x7E
        ◦ 126₁₀ = 126/16=7(14), 7= 7₁₆, 14= E₁₆
        ◦ Результат: 7E₁₆
        ◦ В двоичном: 01111110₂
4. Перевод шестнадцатеричных чисел в 8-битные двоичные
    1. 0x3C → 00111100
        ◦ 3₁₆ = 0011₂, C₁₆ = 1100₂
        ◦ Объединяем: 0011 1100
    2. 0x7E → 01111110
        ◦ 7₁₆ = 0111₂, E₁₆ = 1110₂
        ◦ Объединяем: 0111 1110
    3. 0xFF → 11111111
        ◦ F₁₆ = 1111₂, F₁₆ = 1111₂
        ◦ Объединяем: 1111 1111
    4. 0xA5 → 10100101
        ◦ A₁₆ = 1010₂, 5₁₆ = 0101₂
        ◦ Объединяем: 1010 0101
5. Арифметическое отрицание (integer negation)
Для отрицания в дополнительном коде: инвертируем все биты и прибавляем 1.
    1. 0x3C = 00111100
        ◦ Инверсия: 11000011
        ◦ +1: 11000011 + 1 = 11000100 = 0xC4
        ◦ Проверка: 60 → -60
    2. 0x7E = 01111110
        ◦ Инверсия: 10000001
        ◦ +1: 10000001 + 1 = 10000010 = 0x82
        ◦ Проверка: 126 → -126
    3. 0xFF = 11111111
        ◦ Инверсия: 00000000
        ◦ +1: 00000000 + 1 = 00000001 = 0x01
        ◦ Проверка: -1 → 1
    4. 0xA5 = 10100101
        ◦ Инверсия: 01011010
        ◦ +1: 01011010 + 1 = 01011011 = 0x5B
        ◦ Проверка: -91 → 91
6. Отображение байтов значения 0xDEADBEEF
Исходное значение: 0xDEADBEEF = 4 байта: DE AD BE EF
Big-Endian (старший байт по младшему адресу):
text
Адрес:    0    1    2    3
Значение: DE   AD   BE   EF
Little-Endian (младший байт по младшему адресу):
text
Адрес:    0    1    2    3
Значение: EF   BE   AD   DE
7. Расширение 5-битных чисел до 8-битных
Знаковое расширение (sign-extension):
    • Копируем старший бит (знаковый) во все новые разряды
    1. 7 = 00111 → 00000111
        ◦ Старший бит 0 → дополняем нулями
    2. 15 = 01111 → 00001111
        ◦ Старший бит 0 → дополняем нулями
    3. -16 = 10000 → 11110000
        ◦ Старший бит 1 → дополняем единицами
    4. -5 = 11011 → 11111011
        ◦ Старший бит 1 → дополняем единицами
Расширение нулями (zero-extension):
    • Всегда дополняем нулями
    1. 7 = 00111 → 00000111
    2. 15 = 01111 → 00001111
    3. -16 = 10000 → 00010000
    4. -5 = 11011 → 00011011
8. Сложение 4-битных чисел
Беззнаковые: (7, 9)
text
   0111  (7)
+  1001  (9)
--------
  10000  (16)
    • Результат: 10000 (5 бит)
    • В 4-битном представлении происходит переполнение
Со знаком: (4, -5)
text
   0100  (4)
+  1011  (-5 в доп. коде)
--------
   1111  (-1 в доп. коде)
    • Проверка: 4 + (-5) = -1
    • -1 в 4-битном дополнительном коде: инвертируем 0001 → 1110, +1 = 1111 ✓
9. Обмен значений без временной переменной (XOR-swap)
Алгоритм:
text
x = x ^ y;
y = x ^ y;
x = x ^ y;
Доказательство:
Пусть начальные значения: x = A, y = B
    1. x = x ^ y → x = A ^ B, y = B
    2. y = x ^ y → y = (A ^ B) ^ B = A ^ (B ^ B) = A ^ 0 = A
    3. x = x ^ y → x = (A ^ B) ^ A = B ^ (A ^ A) = B ^ 0 = B
Итог: x = B, y = A
Пример с 6-битными значениями:
Возьмем беззнаковые: A = 13 (001101), B = 24 (011000)
    1. x = 001101 ^ 011000 = 010101 (21)
    2. y = 010101 ^ 011000 = 001101 (13) ✓
    3. x = 010101 ^ 001101 = 011000 (24) ✓
Ограничения:
    1. Нельзя использовать для одной и той же переменной: если x и y указывают на одну ячейку памяти, результат будет 0
    2. Только для целочисленных типов: XOR определен для целых чисел
    3. Для знаковых типов: результат зависит от представления, но работает корректно, так как битовые операции одинаковы
10. Трюки с правым значащим разрядом
1. x & (x - 1) — Выключение младшей установленной 1
Объяснение: Обнуляет самый правый установленный бит (1) в числе.
Доказательство:
    • Пусть x = ...1000...0 (заканчивается на 1 и нули)
    • Тогда x-1 = ...0111...1 (инвертирует все биты после первой 1)
    • x & (x-1) = ...0000...0 (обнуляет самую правую 1)
Примеры (6-битные):
    1. x = 44 = 101100
        ◦ x-1 = 43 = 101011
        ◦ x & (x-1) = 101100 & 101011 = 101000 (40)
        ◦ Обнулили бит в позиции 2
    2. x = 15 = 001111
        ◦ x-1 = 14 = 001110
        ◦ x & (x-1) = 001111 & 001110 = 001110 (14)
        ◦ Обнулили младший бит
Граничные случаи:
    • x = 0: 0 & (-1) = 0
    • x = 2^k - 1: (2^k - 1) & (2^k - 2) = 2^k - 2
2. x | (x + 1) — Включение младшего нулевого бита
Объяснение: Устанавливает в 1 самый правый нулевой бит.
Доказательство:
    • Пусть x = ...0111...1 (заканчивается на 0 и единицы)
    • Тогда x+1 = ...1000...0 (переносит через все единицы)
    • x | (x+1) = ...1111...1 (устанавливает нулевой бит и сохраняет остальные)
Примеры (6-битные):
    1. x = 40 = 101000
        ◦ x+1 = 41 = 101001
        ◦ x | (x+1) = 101000 | 101001 = 101001 (41)
        ◦ Установили бит в позиции 0
    2. x = 21 = 010101
        ◦ x+1 = 22 = 010110
        ◦ x | (x+1) = 010101 | 010110 = 010111 (23)
        ◦ Установили бит в позиции 1
Граничные случаи:
    • x = 2^k - 1: (2^k - 1) | 2^k = 2^(k+1) - 1 (переполнение)
    • x = 0: 0 | 1 = 1
3. x | (x - 1) — Заполнение хвостовых нулей единицами
Объяснение: Заменяет все нули справа от самой правой 1 на единицы.
Доказательство:
    • Пусть x = ...1000...0 (заканчивается на 1 и нули)
    • Тогда x-1 = ...0111...1 (инвертирует нули после 1)
    • x | (x-1) = ...1111...1 (заполняет нули единицами)
Примеры (6-битные):
    1. x = 40 = 101000
        ◦ x-1 = 39 = 100111
        ◦ x | (x-1) = 101000 | 100111 = 101111 (47)
        ◦ Заполнили 3 нуля справа единицами
    2. x = 21 = 010101
        ◦ x-1 = 20 = 010100
        ◦ x | (x-1) = 010101 | 010100 = 010101 (21)
        ◦ Нет хвостовых нулей → не изменилось
Граничные случаи:
    • x = 0: 0 | (-1) = -1 (все единицы)
    • x = 1: 1 | 0 = 1
    • x = 2^k: 2^k | (2^k - 1) = 2^(k+1) - 1
